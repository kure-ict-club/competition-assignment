[2]
・仮引数と実引数は別の変数
<1 参照渡し>(http://cpp-lang.sevendays-study.com/ex-day1.html)(http://www7b.biglobe.ne.jp/~robe/cpphtml/html03/cpp03008.html)
　参照渡しは、引数の受け取り方で、「値渡し」(例: func(int a))、「ポインタ渡し」(例: func(int* a))とは違い、新しいアドレスを割り振らずに直接、他のアドレスを参照し、関数外の変数を書き換える方法。値渡しではできないがポインタ渡しではできる、呼び出し元の自動変数の書き換えも可能。
　constをつけると、関数の中でその変数を変えないことを明示する。
・返り値の参照渡し…メソッドやその宣言の返り値のところに、型の最後に&をつけると、返り値を参照渡しすることができる。参照返しとか、参照戻しという。
注意: 参照返しやポインタ返しするときは、関数内でのみ有効な変数のアドレスを返すことはできない。参照返しやポインタ返しをせず値を返す時は、別のアドレス(呼び出し元の変数)に同じ値を入れているからである。呼び出し元に、ない変数のアドレスを送ることはできない。


<2 演算子のオーバーロード>(https://msdn.microsoft.com/ja-jp/library/5tk49fh2.aspx#%E5%8F%82%E7%85%A7)(http://www.ced.is.utsunomiya-u.ac.jp/lecture/2012/prog/p3/kadai2/page3.php)(http://skru-y.hatenablog.com/entry/2014/01/12/EffectiveC%2B%2B%E3%82%92%E8%AA%AD%E3%82%80_19%E9%A0%85)
　演算子のオーバーロードは次のような構文で行う。
  型 operator 演算子(引数)
例
CCalc operator +(CCalc& 変数); // 宣言(classのh内)
// 中身
CCalc CCalc::operator +(CCalc& other) {
  return CCalc(a + other.a);
}
o1 = o3 + o2;// main関数内で実際に使うとき。o3がo2を引数として、呼び出している。このときo1, o2, o3はCCalc型(CCalcクラス)でないと、処理ができない。
・複数の引数をもつ演算子のオーバーロードでは、「非メンバ関数」として、定義をclass{}の外にやる。[なぜ?]

ワード
・オーバーロード…関数などを、同じ名称で多重に定義すること。例えば、引数の数や型などで(int,boolの引数、intだけの引数など)別々の動作を定義することができる。


<3 ストリーム>(https://ppp-lab.sakura.ne.jp/ProgrammingPlacePlus/cpp/library/027.html#output_operator)
　入出力ストリームの<<演算子をオーバーロードすることで、<<演算子で出力できるようになる? (例はURL参照)

<4 そのほか補足>
・デフォルトコンストラクタを明示する…クラスの宣言で「クラス名(引数…通常ない) = default;」とする。
  ・これを使うには、C++11でコンパイルする必要がある。g++でC++11としてコンパイルするには、次のようにコンパイルする。
    $ g++ -c 〇〇.cpp -std=c++11
・関数の後ろのconstは、メンバ変数を変更しないという意味。(https://ameblo.jp/kohchan1215/entry-11295258721.html)
・メンバ関数で使われることのあるthisとは、呼び出し元のオブジェクトのアドレス?のこと。

